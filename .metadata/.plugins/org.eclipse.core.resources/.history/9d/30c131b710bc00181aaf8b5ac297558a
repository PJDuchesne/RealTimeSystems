/*
__/\\\\\\\\\\\\\_____/\\\\\\\\\\\__/\\\\\\\\\\\\____        
 _\/\\\/////////\\\__\/////\\\///__\/\\\////////\\\__       
  _\/\\\_______\/\\\______\/\\\_____\/\\\______\//\\\_      
   _\/\\\\\\\\\\\\\/_______\/\\\_____\/\\\_______\/\\\_     
    _\/\\\/////////_________\/\\\_____\/\\\_______\/\\\_    
     _\/\\\__________________\/\\\_____\/\\\_______\/\\\_   
      _\/\\\___________/\\\___\/\\\_____\/\\\_______/\\\__  
       _\/\\\__________\//\\\\\\\\\______\/\\\\\\\\\\\\/___
        _\///____________\/////////_______\////////////_____
-> Name:  Monitor.cpp
-> Date: Sept 17, 2018  (Created)
-> Author: Paul Duchesne (B00332119)
-> Contact: pl332718@dal.ca
*/

#include "Includes/Monitor.h"
#include "Includes/RingBuffer.h"
#include "Includes/GlobalConfig.h"

// Singleton Instance
Monitor *Monitor::MonitorInstance_ = new Monitor;

Monitor::Monitor() {
  data_buffer_.reset(new RingBuffer<char>(DATA_BUFFER_SIZE));
}

void Monitor::CentralLoop() {
  MsgType_t type = NONE;
  char data = char();

  // Loop Forever
  while(1)
  {
    CheckMessageHandler(type, data);
  }
}

void Monitor::CheckMessageHandler(MsgType_t &type, char &data) {
  ISRMsgMaker::GetISRMsgMaker()->CheckQueue(type, data);

  if (type == NONE) return;

  // TODO: Make this a function table
  switch (type) {
    case UART:
      HandleUART(data);
      break;
    case SYSTICK:
      HandleSYSTICK();
      break;
    default:
      std::cout << "[CheckMessageHandler()] SWITCH TABLE ERROR: >>" << type << "<<\n";
      break;
  }

}

// TODO: Handle UART
void Monitor::HandleUART(char data) {
  switch (data) {
    case 0x08: // Backspace
    case 0x7F: // Delete
               // Ctrl H???
      // TODO: Handle these
      break;
    case 0x0D: // Enter (Carriage Return)
      // TODO: Handle ENTER
      data_buffer_->Reset();
      break;
    default:  // All other characters, add to buffer
      data_buffer_->Add(data);
      break;
  }
}

// TODO: HandleSYSTICK
void Monitor::HandleSYSTICK() {
}

void Monitor::PrintMsg(char* msg) {
  ISRMsgMaker::GetISRMsgMaker()->QueueOutputMsg(msg);
}

Monitor* Monitor::GetMonitor() {
    // if (!MonitorInstance) MonitorInstance = new Monitor;
    return MonitorInstance_;
}
